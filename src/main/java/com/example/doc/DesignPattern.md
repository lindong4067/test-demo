# 设计模式
## 1.单例模式
单例模式，它的定义就是确保某一个类只有一个实例，并且提供一个全局访问点。
最佳实现：com.example.testpatterns.singleton.practice

## 2.简单工厂
通过一个工厂类来根据不同的type实例化一个接口的不同子类，未必是同一个接口。

## 3.工厂方法
核心的工厂类不再负责所有对象的创建，而是将具体创建对象的工作交给子类去做。
工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。

## 4.抽象工厂
抽象工厂可以，创建相关或依赖对象的家族，而无需明确指定具体类，创建组合产品

## 5.建造者模式
又名生成器模式，是一种对象构建模式，它可以将复杂对象的建造过程抽象出来，使这个抽象过程的不同实现方法可以构造出不同属性的对象。

## 6.原型模式
通过复制现有的实例来创建新的实例

## 7.适配器模式
将一个类的方法接口转换成客户希望的另外一个接口

## 8.组合模式
将对象组合成树形结构以表示“部分-整体”的层次结构

## 9.装饰模式
动态的给对象添加新的功能

## 10.代理模式
为其他对象提供一个代理以便控制这个对象的访问
> 代理模式和装饰模式非常类似，甚至代码都类似。二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能

## 11.享元模式
通过共享技术来有效的支持大量细粒度的对象，区分内部状态与外部状态
> String常量池、数据库连接池、缓冲池等等都是享元模式的应用，所以说享元模式是池技术的重要实现方式。

## 12.外观模式
对外提供一个统一的方法，来访问子系统中的一群接口
> 外观模式的目的不是给予子系统添加新的功能接口，而是为了让外部减少与子系统内多个模块的交互，松散耦合，从而让外部能够更简单地使用子系统。
> 外观模式的本质是：封装交互，简化调用。

## 13.桥接模式
将抽象部分和它的实现部分分离，使它们都可以独立的变化
> 实现系统可能有多个角度分类，每一种角度都可能变化，那么把这种多角度分类给分离出来让他们独立变化，减少他们之间耦合

## 14.模板模式
定义一个算法结构，而将一些步骤延迟到子类实现
> 完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。

## 15.解释器模式
给定一个语言，定义它的文法的一种表示，并定义一个解释器。

## 16.策略模式
定义一系列算法，把他们封装起来，并且使它们可以相互替换。超市给不同顾客的定价

## 17.状态模式
允许一个对象在其对象内部状态改变时改变它的行为

## 18.观察者模式
对象间的一对多的依赖关系，发布订阅模式，如：服务器推送消息

## 19.备忘录模式
在不破坏封装的前提下，保持对象的内部状态，如：游戏状态回退

## 20.中介者模式
用一个中介对象来封装一系列的对象交互，如：房东-中介-租户,聊天室

## 21.命令模式
将命令请求封装为一个对象，使得可以用不同的请求来进行参数化
> 不同请求调用不同命令对象的方法

## 22.访问者模式
在不改变数据结构的前提下，增加作用于一组对象元素的新功能

## 23.责任链模式
将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会，过滤器链

## 24.迭代器模式
一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构

## 六项基本原则
	单一职责原则
	里氏替换原则
	接口隔离原则
	依赖倒置原则
	开闭原则
	迪米特法则（最少知道原则）


	单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
    原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
    工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
    抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
    建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
    代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
    适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
    桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
    装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。
    外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
    享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
    组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
    模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
    策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
    命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
    职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
    状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
    观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
    中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
    迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
    访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
    备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
    解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。



















