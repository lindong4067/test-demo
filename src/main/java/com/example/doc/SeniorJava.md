## Arithmetic
负数转二进制规律:

    1.取负数的绝对值的原码
    2.计算原码的反码
    3.对反码加一，获取补码
    
    例如：整数-1在计算机中如何表示
    1.先取1的原码:  00000000 00000000 00000000 00000001
    2.得反码       11111111 11111111 11111111 11111110
    3.得补码:      11111111 11111111 11111111 11111111

    1.^(亦或运算) 针对二进制，相同的为0，不同的为1
    2.&(与运算) 针对二进制，只要有一个为0，就为0
    3.<<(向左位移) 针对二进制，转换成二进制后向左移动位，后面用0补齐
    4.>>(向右位移) 针对二进制，转换成二进制后向右移动位，高位移入原来高位的值
    5.>>>(无符号右移)  无符号右移，忽略符号位，高位都以0补齐

## Collection
Set和List的区别

    1. Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。

    2. Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 <实现类有HashSet,TreeSet>。

    3. List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 <实现类有ArrayList,LinkedList,Vector> 。

```java
class Demo{
    //Elements只接受Number及其子类
    List<? extends Number> list1 = new ArrayList<>();
    
    //Elements只接受Number及其上层父类
    List<? super Number> list2 = new ArrayList<>();
}
```
## Concurrent

### 同步和异步:
 > 同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO 操作并等待或者轮询的去查看IO 操作是否就绪，而异步是指用户进程触发IO 操作以后便开始做自己的事情，而当IO 操作已经完成的时候会得到IO 完成的通知。

### 阻塞和非阻塞:
 > 阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。
 
### Java 提供了三种创建线程的方法：

    通过实现 Runnable 接口；
    通过继承 Thread 类本身；
    通过 Callable 和 Future 创建线程。

### 通过 Callable 和 Future 创建线程

    1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。
    2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
    3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
    4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。

### 创建线程的三种方式的对比

    1. 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。
    2. 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。

### CAS
    
    概念：
    1.全称compare and swap，一个CPU原子指令，在硬件层面实现的机制，体现了乐观锁的思想。
    2.JVM用C语言封装了汇编调用。Java的基础库中有很多类就是基于JNI调用C接口实现了多线程同步更新的功能。
    
    原理：
    CMS有三个操作数：当前主内存变量的值V，线程本地变量预期值A，线程本地待更新值B。
    当需要更新变量值的时候，会先获取到内存变量值V然后很预期值A进行比较，如果相同则更新为B，
    如果不同，则将最新的变量值更新到预期值中再重新尝试上面的步骤，直到成功为止。
    
    实例：
    AtomicInteger
    
    缺点：
    1.CPU开销比较大, 在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，
    却又一直更新不成功，循环往复，会给CPU带来很大的压力。
    2.不能保证代码块的原子性, CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。
    比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。
    3.ABA问题, 这是CAS机制最大的问题所在。

### 公平锁与非公平锁

#### 概念：
    公平锁：加锁前先查看是否有排队等待的线程，有的话优先处理排在前面的线程，先到先得
    分公平锁：线程加锁时直接尝试获取锁，获取不到就自动到队尾等待
    
#### 实例：
    ReentrantLock 同时支持两种锁
    
    //创建一个非公平锁，默认是非公平锁
    Lock nonFairLock= new ReentrantLock();
    Lock nonFairLock= new ReentrantLock(false);

    //创建一个公平锁，构造传参true
    Lock fairLock= new ReentrantLock(true);
    
#### 场景：
    更多的是直接使用非公平锁：非公平锁比公平锁性能高5-10倍，因为公平锁需要在多核情况下维护一个队列，
    如果当前线程不是队列的第一个无法获取锁，增加了线程切换次数。
    
### 乐观锁与悲观锁

#### 概念：
    悲观锁：假设一定会发生并发冲突，通过阻塞其他所有线程来保证数据的完整性。
    乐观锁：假设不会发生并发冲突，直接不加锁去完成某项更新，如果冲突就返回失败。
    
#### 实例：
    悲观锁：Synchronized多线程同步，具有排他性，也会容易产生死锁。
    乐观锁：
    CAS机制，简单来说会有三个操作数，当前内存变量值V，变量预期值A，即将更新值B，
    当需要更新变量的时候，会直接将变量值V和预期值A进行比较，如果相同，则直接更新为B；
    如果不相同，则当前变量值V刷新到预期值中，然后重新尝试比较更新。
    
#### 场景：    
    乐观锁：适用于数据争用不严重/重试代价不大/需要相应速度快的场景。
    悲观锁：适用于数据争用严重/重试代价大的场景。

### 
    
    



















